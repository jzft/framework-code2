package com.framework.cache;import java.util.Random;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;import com.framework.cache.execption.RedisExecption;public class RedisLock{  public static final String LOCKED = "TRUE";  public static final long MILLI_NANO_CONVERSION = 1000000L;  public static final long DEFAULT_TIME_OUT = 1000L;  public static final Random RANDOM = new Random();  public static final int EXPIRE = 1200;  private String key;  private static RedisTemplate<?, ?> redisTemplate;    static StringRedisSerializer stringSerializer = new StringRedisSerializer();  private boolean locked = false;  public RedisLock(String key)  {	     this.key = (key + "_lock");  }  public boolean lock(long timeout)  {	Long  expireL = timeout/1000;	Integer expire = expireL.intValue()+5;	return lock(timeout,expire);  }  public static void main(String[] args) throws InterruptedException {	 Long a = System.nanoTime();	 Thread.sleep(2000);	 	 System.out.println((System.nanoTime() -a));	 System.out.println(2000*1000000L);  }    public boolean lock(long timeout, int expireSeconds)  {	    long nano = System.nanoTime();    timeout *= 1000000L;    try    {      while (System.nanoTime() - nano < timeout) {        if (RedisHelper.setnx(this.key, "TRUE", Integer.valueOf(expireSeconds))) {          this.locked = true;          return this.locked;        }        Thread.sleep(3L, RANDOM.nextInt(500));      }    } catch (Exception e) {      throw new RedisExecption("Locking error", e);    }    return false;  }  public boolean lock()  {    return lock(1000L);  }    public void unlock()  {    if (this.locked)      try {    	  RedisHelper.del(this.key);      } catch (RedisExecption e) {        throw e;      }  }      }